#!/usr/bin/env bash
set -euo pipefail

# Debug mode (set CLAUDE_DEBUG=true for verbose output)
DEBUG="${CLAUDE_DEBUG:-false}"

# Logging functions
debug_log() {
  if [[ "${DEBUG}" == "true" ]]; then
    echo "DEBUG: $*" >&2
  fi
}

log_error() {
  echo "ERROR: $*" >&2
}

log_warn() {
  echo "WARNING: $*" >&2
}

# Git identity for Claude Code operations
readonly CLAUDE_GIT_NAME="Claude Code Bot"
readonly CLAUDE_GIT_EMAIL="claude-code@smartwatermelon.github"
readonly CLAUDE_SSH_KEY="${HOME}/.ssh/id_ed25519_claude_code"
readonly CLAUDE_GH_TOKEN_FILE="${HOME}/.config/claude-code/gh-token"

# 1Password secrets configuration
readonly CLAUDE_OP_GLOBAL_SECRETS="${HOME}/.config/claude-code/secrets.op"

# Project secrets must be canonicalized to prevent path traversal
# Only load if inside a git repository
readonly CLAUDE_OP_PROJECT_SECRETS=".claude/secrets.op"
readonly CLAUDE_OP_LOCAL_SECRETS=".claude/secrets.local.op"

# Set Git author/committer identity
export GIT_AUTHOR_NAME="${CLAUDE_GIT_NAME}"
export GIT_AUTHOR_EMAIL="${CLAUDE_GIT_EMAIL}"
export GIT_COMMITTER_NAME="${CLAUDE_GIT_NAME}"
export GIT_COMMITTER_EMAIL="${CLAUDE_GIT_EMAIL}"

debug_log "Git identity: ${CLAUDE_GIT_NAME} <${CLAUDE_GIT_EMAIL}>"

# Use dedicated SSH key with proper quoting
if [[ -f "${CLAUDE_SSH_KEY}" ]]; then
  printf -v GIT_SSH_COMMAND 'ssh -i %q -o IdentitiesOnly=yes' "${CLAUDE_SSH_KEY}"
  export GIT_SSH_COMMAND
  debug_log "Using SSH key: ${CLAUDE_SSH_KEY}"
else
  debug_log "SSH key not found: ${CLAUDE_SSH_KEY}"
fi

# Validate file permissions - BLOCKING (returns 1 if insecure)
check_file_permissions() {
  local file="$1"
  local perms

  # Get permissions (Darwin vs Linux stat syntax)
  perms="$(stat -f '%A' "${file}" 2>/dev/null || stat -c '%a' "${file}" 2>/dev/null || echo "unknown")"

  if [[ "${perms}" == "unknown" ]]; then
    log_error "Could not check permissions for ${file}"
    return 1
  fi

  # Check if group has ANY permissions (middle digit must be 0)
  if [[ "${perms:1:1}" != "0" ]]; then
    log_error "${file} has group permissions (${perms}), refusing to load"
    return 1
  fi

  # Check if world has ANY permissions (last digit must be 0)
  if [[ "${perms: -1}" != "0" ]]; then
    log_error "${file} has world permissions (${perms}), refusing to load"
    return 1
  fi

  # Verify file is owned by current user
  local file_owner
  local current_uid
  file_owner="$(stat -f '%u' "${file}" 2>/dev/null || stat -c '%u' "${file}" 2>/dev/null || echo "unknown")"
  current_uid="$(id -u)" || current_uid="unknown"
  if [[ "${file_owner}" != "${current_uid}" ]]; then
    log_error "${file} is not owned by current user (owner: ${file_owner}, current: ${current_uid})"
    return 1
  fi

  debug_log "File permissions OK for ${file}: ${perms}"
  return 0
}

# Canonicalize and validate path - prevents traversal attacks
canonicalize_path() {
  local path="$1"
  local canonical

  # Check if file exists before canonicalizing
  if [[ ! -e "${path}" ]]; then
    return 1
  fi

  # Get canonical path (resolves symlinks, removes .., etc)
  canonical="$(realpath "${path}" 2>/dev/null || readlink -f "${path}" 2>/dev/null || echo "")"

  if [[ -z "${canonical}" ]]; then
    log_error "Could not canonicalize path: ${path}"
    return 1
  fi

  # Verify no symlinks in the final path component
  if [[ -L "${path}" ]]; then
    log_error "Refusing to load from symlink: ${path}"
    return 1
  fi

  echo "${canonical}"
  return 0
}

# Check if path is contained within parent directory
path_is_under() {
  local child="$1"
  local parent="$2"

  # Must be equal or have parent as prefix with trailing slash
  [[ "${child}" == "${parent}" ]] || [[ "${child}" == "${parent}/"* ]]
}

# Load GitHub CLI token with security checks
if [[ -f "${CLAUDE_GH_TOKEN_FILE}" ]]; then
  if check_file_permissions "${CLAUDE_GH_TOKEN_FILE}"; then
    # Use Bash built-in read instead of cat
    GH_TOKEN="$(<"${CLAUDE_GH_TOKEN_FILE}")"
    export GH_TOKEN
    debug_log "GitHub token loaded successfully"
  else
    log_error "GitHub token file has insecure permissions, refusing to load"
    exit 1
  fi
else
  debug_log "GitHub token file not found: ${CLAUDE_GH_TOKEN_FILE}"
fi

# Normalize env file by quoting unquoted values
# This ensures values with special characters (like \n in private keys) pass safety checks
# and source correctly. Uses single quotes to preserve literal values.
normalize_env_file() {
  local input_file="$1"
  local output_file="$2"
  local line key value

  while IFS= read -r line || [[ -n "${line}" ]]; do
    # Skip blank lines and comments
    if [[ -z "${line}" ]] || [[ "${line}" =~ ^[[:space:]]*# ]]; then
      echo "${line}"
      continue
    fi

    # Match KEY=value pattern
    if [[ "${line}" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"

      # If already quoted (starts and ends with matching quotes), pass through
      if [[ "${value}" =~ ^\".*\"$ ]] || [[ "${value}" =~ ^\'.*\'$ ]]; then
        echo "${line}"
      else
        # Wrap in single quotes, escaping any internal single quotes
        # Replace ' with '\'' (end quote, escaped literal quote, start quote)
        value="${value//\'/\'\\\'\'}"
        echo "${key}='${value}'"
      fi
    else
      # Non-assignment lines pass through unchanged
      echo "${line}"
    fi
  done <"${input_file}" >"${output_file}"
}

# Validate secrets file with path canonicalization
validate_secrets_file() {
  local file="$1"
  local canonical

  if [[ ! -f "${file}" ]]; then
    return 1
  fi

  # Canonicalize path to prevent traversal
  if ! canonical="$(canonicalize_path "${file}")"; then
    return 1
  fi
  if [[ -z "${canonical}" ]]; then
    return 1
  fi

  if [[ ! -r "${canonical}" ]]; then
    log_error "Cannot read ${canonical}"
    return 1
  fi

  # BLOCKING permission check
  if ! check_file_permissions "${canonical}"; then
    log_error "Refusing to load secrets from ${canonical} due to insecure permissions"
    return 1
  fi

  # Return canonical path via stdout for caller to use
  echo "${canonical}"
  return 0
}

# Detect non-interactive/automated contexts where 1Password should be skipped
# Use canonical stdin TTY check as primary signal
SKIP_OP_AUTH=false

# Check for explicit skip flag
if [[ "${CLAUDE_SKIP_OP_AUTH:-false}" == "true" ]]; then
  SKIP_OP_AUTH=true
  debug_log "1Password auth skipped: CLAUDE_SKIP_OP_AUTH=true"
fi

# Check if stdin is NOT a TTY (non-interactive context)
if [[ ! -t 0 ]]; then
  SKIP_OP_AUTH=true
  debug_log "1Password auth skipped: stdin is not a TTY (non-interactive context)"
fi

# Additional checks for CI environments that may allocate PTYs
if [[ "${CI:-false}" == "true" ]] || [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ -n "${GITLAB_CI:-}" ]]; then
  SKIP_OP_AUTH=true
  debug_log "1Password auth skipped: running in CI environment"
fi

# 1Password session and secrets handling
OP_ENABLED=false
OP_ENV_ARGS=()

if command -v op &>/dev/null && [[ "${SKIP_OP_AUTH}" == "false" ]]; then
  OP_VERSION="$(op --version 2>/dev/null)" || OP_VERSION="unknown"
  debug_log "1Password CLI detected (version: ${OP_VERSION})"

  echo "[Claude wrapper] Checking 1Password authentication..." >&2

  # Check for active session and attempt signin if needed
  if ! op account get &>/dev/null; then
    debug_log "No active 1Password session, attempting signin..."

    # Attempt signin (may succeed silently via app integration)
    # Use || true to ignore exit code - we'll check session status next
    # stderr is NOT suppressed so user can see diagnostic errors
    op signin || true
  fi

  # Now check if we have a valid session (single source of truth)
  if op account get &>/dev/null; then
    debug_log "1Password session active"
    # Check for secrets files in priority order
    # Later files override earlier ones (1Password behavior)

    # Global secrets (always absolute path, safe)
    if validated_path="$(validate_secrets_file "${CLAUDE_OP_GLOBAL_SECRETS}")"; then
      OP_ENV_ARGS+=(--env-file="${validated_path}")
      debug_log "Added global secrets (validated)"
    fi

    # Project secrets - only load if we're in a git repository
    # This prevents loading arbitrary secrets from untrusted directories
    if git rev-parse --git-dir &>/dev/null; then
      # Get git repo root and canonicalize it
      GIT_ROOT_RAW="$(git rev-parse --show-toplevel 2>/dev/null)"
      if [[ -n "${GIT_ROOT_RAW}" ]]; then
        # Canonicalize git root to handle symlinks
        GIT_ROOT="$(realpath "${GIT_ROOT_RAW}" 2>/dev/null || echo "${GIT_ROOT_RAW}")"

        PROJECT_SECRETS="${GIT_ROOT}/${CLAUDE_OP_PROJECT_SECRETS}"
        if validated_path="$(validate_secrets_file "${PROJECT_SECRETS}")"; then
          # Ensure canonical path is contained within git repo (proper boundary check)
          if path_is_under "${validated_path}" "${GIT_ROOT}"; then
            OP_ENV_ARGS+=(--env-file="${validated_path}")
            debug_log "Added project secrets (validated)"
          else
            log_error "Project secrets path escapes git repository, refusing to load"
          fi
        fi

        LOCAL_SECRETS="${GIT_ROOT}/${CLAUDE_OP_LOCAL_SECRETS}"
        if validated_path="$(validate_secrets_file "${LOCAL_SECRETS}")"; then
          # Ensure canonical path is contained within git repo (proper boundary check)
          if path_is_under "${validated_path}" "${GIT_ROOT}"; then
            OP_ENV_ARGS+=(--env-file="${validated_path}")
            debug_log "Added local secrets (validated)"
          else
            log_error "Local secrets path escapes git repository, refusing to load"
          fi
        fi
      fi
    else
      debug_log "Not in a git repository, skipping project/local secrets"
    fi

    # Enable 1Password if we have at least one secrets file
    if [[ ${#OP_ENV_ARGS[@]} -gt 0 ]]; then
      OP_ENABLED=true
      debug_log "1Password enabled with ${#OP_ENV_ARGS[@]} secrets file(s)"
    else
      debug_log "No secrets files found, 1Password disabled"
    fi
  else
    # No valid session - authentication failed or was cancelled
    log_warn "1Password authentication failed or cancelled - continuing without secrets"
    debug_log "No active 1Password session, proceeding without secrets"
  fi
else
  if [[ "${SKIP_OP_AUTH}" == "true" ]]; then
    debug_log "1Password authentication skipped (automated/non-interactive context)"
  else
    debug_log "1Password CLI not found in PATH"
  fi
fi

# Find and validate real claude binary
WRAPPER_PATH="$(realpath "${BASH_SOURCE[0]}")"
CLAUDE_BIN=""

debug_log "Searching for claude binary (excluding ${WRAPPER_PATH})"

# Search PATH first
while IFS= read -r candidate; do
  candidate_real="$(realpath "${candidate}" 2>/dev/null || echo "${candidate}")"
  if [[ "${candidate_real}" != "${WRAPPER_PATH}" ]] && [[ -x "${candidate}" ]]; then
    CLAUDE_BIN="${candidate}"
    debug_log "Found claude binary via PATH: ${CLAUDE_BIN}"
    break
  fi
done < <(type -ap claude 2>/dev/null || true)

# Fallback to known locations
if [[ -z "${CLAUDE_BIN}" ]]; then
  for candidate in "${HOME}/.local/bin/claude" "${HOME}/.claude/local/claude" "${HOME}/.npm-global/bin/claude" "/opt/homebrew/bin/claude" "/usr/local/bin/claude"; do
    if [[ -x "${candidate}" ]]; then
      candidate_real="$(realpath "${candidate}" 2>/dev/null || echo "${candidate}")"
      if [[ "${candidate_real}" != "${WRAPPER_PATH}" ]]; then
        CLAUDE_BIN="${candidate}"
        debug_log "Found claude binary at fallback location: ${CLAUDE_BIN}"
        break
      fi
    fi
  done
fi

if [[ -z "${CLAUDE_BIN}" ]]; then
  log_error "Could not find claude binary"
  debug_log "Search paths exhausted, no claude binary found"
  exit 1
fi

# Validate claude binary before executing
validate_claude_binary() {
  local binary="$1"
  local binary_owner
  local binary_perms

  # Get canonical path
  binary="$(realpath "${binary}" 2>/dev/null || echo "${binary}")"

  # Must be executable
  if [[ ! -x "${binary}" ]]; then
    log_error "Claude binary is not executable: ${binary}"
    return 1
  fi

  # Check owner (should be current user or root)
  local current_uid
  binary_owner="$(stat -f '%u' "${binary}" 2>/dev/null || stat -c '%u' "${binary}" 2>/dev/null || echo "unknown")"
  current_uid="$(id -u)" || current_uid="unknown"
  if [[ "${binary_owner}" != "${current_uid}" ]] && [[ "${binary_owner}" != "0" ]]; then
    log_error "Claude binary has unexpected owner (${binary_owner}): ${binary}"
    return 1
  fi

  # Check permissions (should not be world-writable)
  binary_perms="$(stat -f '%A' "${binary}" 2>/dev/null || stat -c '%a' "${binary}" 2>/dev/null || echo "unknown")"
  if [[ "${binary_perms: -1}" =~ [2367] ]]; then
    log_error "Claude binary is world-writable (${binary_perms}): ${binary}"
    return 1
  fi

  debug_log "Claude binary validated: ${binary} (owner: ${binary_owner}, perms: ${binary_perms})"
  return 0
}

# Validate before exec
if ! validate_claude_binary "${CLAUDE_BIN}"; then
  log_error "Claude binary failed security validation, refusing to execute"
  exit 1
fi

# Launch claude with or without 1Password secrets injection
if [[ "${OP_ENABLED}" == "true" ]]; then
  debug_log "Loading secrets from ${#OP_ENV_ARGS[@]} file(s) and executing ${CLAUDE_BIN}"

  # Extract file paths from --env-file=path arguments
  declare -a secret_files=()
  for arg in "${OP_ENV_ARGS[@]}"; do
    secret_files+=("${arg#--env-file=}")
  done

  # Create temp directory for all resolved secret files
  # This ensures proper cleanup even if processing multiple files
  temp_dir="$(mktemp -d)" || {
    log_error "Failed to create temp directory for secret resolution"
    exit 1
  }
  trap 'rm -rf "${temp_dir}"' EXIT

  # Process each secrets file using op inject --in-file/--out-file
  # This approach avoids manual parsing edge cases (CRLF, empty values, etc)
  # and preserves stdin as a TTY unlike op run
  for secrets_file in "${secret_files[@]}"; do
    debug_log "Injecting secrets from: ${secrets_file}"

    # Verify file is readable before processing
    if [[ ! -r "${secrets_file}" ]]; then
      log_error "Cannot read secrets file: ${secrets_file}"
      exit 1
    fi

    # Strip comments before passing to op inject
    # This prevents op inject from trying to resolve op:// patterns in comments
    # grep -v returns exit 1 when no matches (no comments), which is fine
    stripped_file="${temp_dir}/stripped-$(basename "${secrets_file}")"
    grep -v '^[[:space:]]*#' "${secrets_file}" >"${stripped_file}" || true

    # Create temp file for resolved secrets
    resolved_file="${temp_dir}/resolved-$(basename "${secrets_file}")"

    # Inject 1Password references - fails if any reference cannot be resolved
    # Use stripped file to avoid resolving op:// patterns in comments
    if ! op inject --in-file="${stripped_file}" --out-file="${resolved_file}" 2>&1; then
      log_error "Failed to inject secrets from ${secrets_file}"
      exit 1
    fi

    # Normalize resolved file: quote unquoted values to handle special characters
    # This ensures values like private keys with \n sequences pass safety checks
    normalized_file="${temp_dir}/normalized-$(basename "${secrets_file}")"
    normalize_env_file "${resolved_file}" "${normalized_file}"
    mv "${normalized_file}" "${resolved_file}"

    # Validate resolved file contains only safe variable assignments
    # Note: Empty files (from comment-only secrets files) are valid and handled by validation
    # Allows quoted values but blocks command execution metacharacters
    # Pattern matches: KEY=value, KEY="value", KEY='value' (with '\'' escapes), comments, blank lines
    # Blocks: semicolons, backticks, $(), pipes, redirects outside quotes
    # Single-quote pattern handles '\'' escape sequences (e.g., 'it'\''s working')
    safe_pattern="^([A-Za-z_][A-Za-z0-9_]*=(\"[^\"]*\"|'[^']*'(\\\\''[^']*')*|[^;\\\`\$()&<>|[:space:]]+)|#.*|[[:space:]]*)$"
    if grep -vE "${safe_pattern}" "${resolved_file}" >/dev/null 2>&1; then
      log_error "Resolved secrets file contains unsafe content: ${secrets_file}"
      debug_log "Unsafe lines found:"
      grep -vE "${safe_pattern}" "${resolved_file}" >&2 || true
      exit 1
    fi

    # Source the resolved env file with proper variable export
    # Use set -a to auto-export all variables defined in the file
    set -a
    # shellcheck disable=SC1090
    source "${resolved_file}" || {
      log_error "Failed to source resolved secrets from ${secrets_file}"
      set +a
      exit 1
    }
    set +a

    debug_log "Loaded secrets from ${secrets_file}"
  done

  # Project-specific pre-launch hook (runs after secrets loaded, before claude starts)
  # Security: requires executable permission and passes same ownership/permission checks as secrets files
  PRE_LAUNCH_HOOK="${GIT_ROOT}/.claude/pre-launch.sh"
  if [[ -n "${GIT_ROOT:-}" ]] && [[ -x "${PRE_LAUNCH_HOOK}" ]]; then
    if check_file_permissions "${PRE_LAUNCH_HOOK}"; then
      debug_log "Running project pre-launch hook: ${PRE_LAUNCH_HOOK}"
      # shellcheck source=/dev/null
      source "${PRE_LAUNCH_HOOK}"
    else
      warn_log "Skipping pre-launch hook - insecure permissions: ${PRE_LAUNCH_HOOK}"
    fi
  fi

  debug_log "Executing: ${CLAUDE_BIN} [${#} args] with secrets loaded"
  exec "${CLAUDE_BIN}" "$@"
else
  debug_log "Executing: ${CLAUDE_BIN} [${#} args]"
  exec "${CLAUDE_BIN}" "$@"
fi
